<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- 
	000000book
	Graffiti Markup Language (GML) playback using HTML5 canvas and Processing.js

	by Jamie Dubs <http://github.com/jamiew>

	v2: supports multiple strokes, looping, better stage positioning	
	TODO: 
		* use time data in play back (right now it's continuous time... boring)
		* draw curves instead of simple lines
-->
<html>
<head>
	<title>canvasplayer: GML Playback using Processing.js</title>
	<style type="text/css" media="screen">
		body { background: #fff; color: #222; font-family: sans-serif;margin: 0 auto; text-align: center; }
		body, canvas { width: 800px; }
		canvas { height: 600px; background-color: #000; border: 5px solid #222; }		
		a, a:hover { color: #9f9f77; }
		h1 { letter-spacing: -1px; color: #000; }
		h2 { font-family: "Arial", sans-serif; font-weight: normal; }
		#loading { position: absolute; margin: -5px 0 0 -10px; }
	</style>
</head>
<body>
	<div id="loading"><img src="http://www.histats.com/images/loading1.gif" alt="" title="" /></div>		
	<h1>canvasplayer: GML Playback using Processing.js</h1>	
  <canvas id="canvas"></canvas>
	<p>
		Code available at <a href="http://github.com/jamiew/canvasplayer">github.com/jamiew/canvasplayer</a>		
		&mdash; tag by Katsu, <a href="http://000000book.com/data/161">download GML</a>
    <p>
    <strong>GML Webring:</strong> <a href="http://fffff.at/gml-week-graffiti-markup-language/">intro</a> / <a href="http://fffff.at/tag/gmlweek">recent projects</a> / <a href="http://fffff.at/gml">GML spec</a> / <a href="http://000000book.com">data (#000000book)</a>
	</p>

	
	<!-- Our Code! -->
  <script id="sketch" type="text/javascript">

	// big TODO: use the time data instead of just doing continuous time playback
	void setup() {
		console.log("setup()");
		console.log(gml);

		// setup our canvas
		size(800, 600);
		frameRate(60);
		background(0);
		// smooth();

		// read data from the GML (GSON), loaded via #000000book JSONp callback
		// the <script> tag is finicky if not at the bottom of the page, after the Processing.js sketch
		pts = []
		strokes = (gml.tag.drawing.stroke instanceof Array ? gml.tag.drawing.stroke : [gml.tag.drawing.stroke]);
		for(i in strokes){ 
			// console.log("reading stroke "+i);
			pts = pts.concat(strokes[i].pt);
			pts.push(undefined); //blank obj to indicate new stroke
		}
		
		// read orientation/scaling headers from the GML
		// FIXME - DustTag GML not specifying a orientation/scaling, so we're explicitly fixing known iPhone apps
		var app_name = gml.tag.header && gml.tag.header.client && gml.tag.header.client.name;
		if(app_name == 'Graffiti Analysis 2.0: DustTag' || app_name == 'DustTag: Graffiti Analysis 2.0' || app_name == 'Fat Tag - Katsu Edition'){
			rotation = 80;
			translation = [0, 800]; // still gets cropped; should scale down all values
			console.log('GML is known iPhone app, scaling...');
		} else {
			rotation = 0;
			translation = [0, 0];
			console.log("Unknown appplication source: "+app_name);		
			// console.log(gml.tag.header);
		}
		console.log("rotation="+rotation+" translation="+translation);
	}

	void draw() {
		i = frameCount % pts.length;
		if(i == pts.length - 1){ console.log(serialize(document.getElementById("canvas"))); }
		
		prev = pts[i-1];
		pt = pts[i];
		
		// drawing rules
		if(i == 0){ background(0); } // clear on restart (first frame)
		if(pt == undefined || pt == []){ return; } // if missing current pt, we are skipping		
		if(prev == undefined || prev == []){ prev = pt; } // if missing the prev, we're at the beginning of a new stroke
		
		// calculations
		dimx = (prev.x -pt.x)*width;
		dimy = (prev.y -pt.y)*height;
		hyp = 1/(sqrt(pow(dimx,2),pow(dimy,2)) + 25);
		// console.log('stroke prev.x='+prev.x+' prev.y='+prev.y+' pt.x='+pt.x+' pt.y='+pt.y+' |  dimx='+dimx+' dimy='+dimy+' hyp='+hyp);

		// transform display space if specified
		translate(translation[0], translation[1]);
		rotate(rotation);

		// finally... draw!
		strokeWeight(hyp * 200);
		stroke(255);		
		line(prev.x*width, prev.y*height, pt.x*width, pt.y*height);

	}
  </script>
  <script src="processing.min.js" type="text/javascript" charset="utf-8"></script>			

	
	<!-- the GML data, served from #000000book and initialized in a callback -->	
	<script type="text/javascript" charset="utf-8">

		// mock console.log() if no Firebug etc. 
		if(!console || !console.log) {
			var console = new Array();
			console.log = function () {}
		}

 		// callback method
		function load_gml(data){
			gml = data.gml;
			document.getElementById("loading").innerHTML = '';
			// console.log("load_gml()");
			// console.log(gml);
			var canvas = document.getElementById("canvas"); 
			var sketch = document.getElementById("sketch").text; 
			var p = Processing(canvas, sketch, gml);
		};
		
		// image serialization/deserialization, for sending thumbnail to #000000book
		// EXPERIMENTAL!
		function serialize(canvas) {
			return canvas.toDataURL();
		}

		function deserialize(data, canvas) {
			var img = new Image();
			img.onload = function() {
				canvas.width = img.width;
				canvas.height = img.height;
				canvas.getContext("2d").drawImage(img, 0, 0);
			};
			img.src = data;
		}

	</script>
	
	<script src="http://000000book.com/data/161.json?callback=load_gml" type="text/javascript" charset="utf-8"></script>	
	<!-- 
		Some cool tags:
		* /data/latest.json
		* /data/random.json
		* /data/148 : hello world
		* /data/161 : Katsu
		* /data/158 : Jesus Saves	
		* /data/818 : Hell
	-->
	
	
</body>
</html>
